/*
 *
 *  This file is part of the software MonaLisa.
 *  MonaLisa is free software, dependent on non-free software. For more information read LICENCE and README.
 *
 *  (c) Department of Molecular Bioinformatics, Institute of Computer Science, Johann Wolfgang
 *  Goethe-University Frankfurt am Main, Germany
 *
 */
package monalisa.addons.netproperties;

import java.awt.Color;
import java.util.HashMap;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import monalisa.addons.AddonPanel;
import monalisa.addons.netviewer.listener.MyColorOptionsMouseListener;
import monalisa.addons.netviewer.NetViewer;
import monalisa.data.pn.Place;
import monalisa.data.pn.Transition;
import monalisa.data.pn.UniquePetriNetEntity;
import javax.swing.JFileChooser;
import monalisa.data.pn.PetriNetFacade;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

/**
 * Panel (with its components) for the net properties.
 *
 * @ jens & daniel
 */
public class NetPropertiesPanel extends AddonPanel {

    protected ColorMap colorMap;

    private Ordinary ordinary;
    private Homogenous homogenous;
    private NonBlockingMultiplicity nonBlockingMultiplicity;
    private Pure pure;
    private Conservative conservative;
    private SubConservative subConservative;
    private StaticConflictFree staticConflictFree;
    private Connected connected;
    private StronglyConnected stronglyConnected;
    private TransitionWithoutPrePlace transitionWithoutPrePlace;
    private TransitionWithoutPostPlace transitionWithoutPostPlace;
    private PlaceWithoutPreTransition placeWithoutPreTransition;
    private PlaceWithoutPostTransition placeWithoutPostTransition;

    private HashMap<JCheckBox, NetPropertyAlgorithm> algorithmMap = new HashMap<>();
    private HashMap<JCheckBox, NetPropertyAlgorithm> oneSidedAlgorithmMap = new HashMap<>();
    private HashMap<JCheckBox, JLabel> labelMap = new HashMap<>();
    private NetPropertiesPanelLogic netPropertiesPanelLogic;
    private final JFileChooser jFileChooser = new JFileChooser();
    private boolean jButtonCheckAlgorithmIsSelected;
    private static final Logger LOGGER = LogManager.getLogger(NetPropertiesPanel.class);

    /**
     * Creates new form NetPropertiesPanel
     */
    public NetPropertiesPanel(NetViewer netViewer, PetriNetFacade petriNet) {
        super(netViewer, petriNet, "NetProperties");
        LOGGER.info("Initializing NetPropertiesPanel");
        initComponents();

        colorMap = new ColorMap();

        algorithmMap = getAlgorithmMap();
        oneSidedAlgorithmMap = getOneSidedAlgorithmMap();
        labelMap = getLabelMap();
        jLabelTransitionWithoutPrePlaceColor.addMouseListener(new MyColorOptionsMouseListener(jLabelTransitionWithoutPrePlaceColor));
        jLabelTransitionWithoutPostPlaceColor.addMouseListener(new MyColorOptionsMouseListener(jLabelTransitionWithoutPostPlaceColor));
        jLabelPlaceWithoutPreTransitionColor.addMouseListener(new MyColorOptionsMouseListener(jLabelPlaceWithoutPreTransitionColor));
        jLabelPlaceWithoutPostTransitionColor.addMouseListener(new MyColorOptionsMouseListener(jLabelPlaceWithoutPostTransitionColor));
        LOGGER.info("Successfully initialized NetPropertiesPanel");
    }

    protected void setColorOfNetViewerNode(UniquePetriNetEntity upne, Color c) {
        LOGGER.debug("Setting color of NetViewer node");
        if (upne.getClass().getName().contains("Place")) {
            netViewer.getNodeFromVertex(upne).getMasterNode().setColorForAllNodes(c);
        } else if (upne.getClass().getName().contains("Transition")) {
            netViewer.getNodeFromVertex(((Transition) upne)).setColorForAllNodes(c);
        }
        netViewer.repaint();
        LOGGER.debug("Successfully set color of NetViewer node");
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        jCheckBoxTransitionWithoutPrePlace = new javax.swing.JCheckBox();
        jCheckBoxTransitionWithoutPostPlace = new javax.swing.JCheckBox();
        jCheckBoxPlaceWithoutPreTransition = new javax.swing.JCheckBox();
        jCheckBoxPlaceWithoutPostTransition = new javax.swing.JCheckBox();
        jLabelOrdinary = new javax.swing.JLabel();
        jCheckBoxOrdinary = new javax.swing.JCheckBox();
        jLabelOrdinaryReturn = new javax.swing.JLabel();
        jLabelHomogenous = new javax.swing.JLabel();
        jCheckBoxHomogenous = new javax.swing.JCheckBox();
        jLabelNonBlockingMultiplicity = new javax.swing.JLabel();
        jLabelPure = new javax.swing.JLabel();
        jLabelConservative = new javax.swing.JLabel();
        jLabelStaticConflictFree = new javax.swing.JLabel();
        jLabelConnected = new javax.swing.JLabel();
        jLabelStronglyConnected = new javax.swing.JLabel();
        jCheckBoxNonBlockingMultiplicity = new javax.swing.JCheckBox();
        jCheckBoxPure = new javax.swing.JCheckBox();
        jCheckBoxConservative = new javax.swing.JCheckBox();
        jCheckBoxStaticConflictFree = new javax.swing.JCheckBox();
        jCheckBoxConnected = new javax.swing.JCheckBox();
        jCheckBoxStronglyConnected = new javax.swing.JCheckBox();
        jLabelHomogenousReturn = new javax.swing.JLabel();
        jLabelNonBlockingMultiplicityReturn = new javax.swing.JLabel();
        jLabelPureReturn = new javax.swing.JLabel();
        jLabelConservativeReturn = new javax.swing.JLabel();
        jLabelStaticConflictFreeReturn = new javax.swing.JLabel();
        jLabelConnectedReturn = new javax.swing.JLabel();
        jLabelStronglyConnectedReturn = new javax.swing.JLabel();
        jLabelElementaryNetPropertiesHeadline = new javax.swing.JLabel();
        jLabelOneSidedNodesHeadline = new javax.swing.JLabel();
        jLabelSelectAllAlgorithms = new javax.swing.JLabel();
        jRadioButtonSelectAllAlgorithms = new javax.swing.JRadioButton();
        jLabelTransitionWithoutPrePlace = new javax.swing.JLabel();
        jLabelTransitionWithoutPostPlace = new javax.swing.JLabel();
        jLabelPlaceWithoutPreTransition = new javax.swing.JLabel();
        jLabelPlaceWithoutPostTransition = new javax.swing.JLabel();
        jLabelTransitionWithoutPrePlaceColor = new javax.swing.JLabel();
        jLabelTransitionWithoutPostPlaceColor = new javax.swing.JLabel();
        jLabelPlaceWithoutPreTransitionColor = new javax.swing.JLabel();
        jLabelPlaceWithoutPostTransitionColor = new javax.swing.JLabel();
        jButtonCheckAlgorithms = new javax.swing.JButton();
        jLabelSubConservative = new javax.swing.JLabel();
        jCheckBoxSubConservative = new javax.swing.JCheckBox();
        jLabelSubConservativeReturn = new javax.swing.JLabel();
        helpButton = new javax.swing.JButton();

        setPreferredSize(new java.awt.Dimension(310, 550));
        setLayout(new java.awt.GridBagLayout());

        jCheckBoxTransitionWithoutPrePlace.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxTransitionWithoutPrePlaceActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
        add(jCheckBoxTransitionWithoutPrePlace, gridBagConstraints);

        jCheckBoxTransitionWithoutPostPlace.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxTransitionWithoutPostPlaceActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
        add(jCheckBoxTransitionWithoutPostPlace, gridBagConstraints);

        jCheckBoxPlaceWithoutPreTransition.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxPlaceWithoutPreTransitionActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
        add(jCheckBoxPlaceWithoutPreTransition, gridBagConstraints);

        jCheckBoxPlaceWithoutPostTransition.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxPlaceWithoutPostTransitionActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
        add(jCheckBoxPlaceWithoutPostTransition, gridBagConstraints);

        jLabelOrdinary.setText("ordinary");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jLabelOrdinary, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jCheckBoxOrdinary, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 2);
        add(jLabelOrdinaryReturn, gridBagConstraints);

        jLabelHomogenous.setText("homogenous");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 7;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jLabelHomogenous, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 7;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jCheckBoxHomogenous, gridBagConstraints);

        jLabelNonBlockingMultiplicity.setText("non-blocking multiplicity");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 8;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jLabelNonBlockingMultiplicity, gridBagConstraints);

        jLabelPure.setText("pure");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 9;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jLabelPure, gridBagConstraints);

        jLabelConservative.setText("conservative");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 10;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jLabelConservative, gridBagConstraints);

        jLabelStaticConflictFree.setText("static conflict free");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 12;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jLabelStaticConflictFree, gridBagConstraints);

        jLabelConnected.setText("connected");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 13;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jLabelConnected, gridBagConstraints);

        jLabelStronglyConnected.setText("strongly connected");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 14;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jLabelStronglyConnected, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 8;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jCheckBoxNonBlockingMultiplicity, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 9;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jCheckBoxPure, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 10;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jCheckBoxConservative, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 12;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jCheckBoxStaticConflictFree, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 13;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jCheckBoxConnected, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 14;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jCheckBoxStronglyConnected, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 7;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 2);
        add(jLabelHomogenousReturn, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 8;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 2);
        add(jLabelNonBlockingMultiplicityReturn, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 9;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 2);
        add(jLabelPureReturn, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 10;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 2);
        add(jLabelConservativeReturn, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 12;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 2);
        add(jLabelStaticConflictFreeReturn, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 13;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 2);
        add(jLabelConnectedReturn, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 14;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 2);
        add(jLabelStronglyConnectedReturn, gridBagConstraints);

        jLabelElementaryNetPropertiesHeadline.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
        jLabelElementaryNetPropertiesHeadline.setText("Elementary net properties");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.insets = new java.awt.Insets(15, 0, 5, 0);
        add(jLabelElementaryNetPropertiesHeadline, gridBagConstraints);

        jLabelOneSidedNodesHeadline.setFont(new java.awt.Font("Dialog", 1, 14)); // NOI18N
        jLabelOneSidedNodesHeadline.setText("One-sided nodes");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 5, 0);
        add(jLabelOneSidedNodesHeadline, gridBagConstraints);

        jLabelSelectAllAlgorithms.setFont(new java.awt.Font("Dialog", 1, 13)); // NOI18N
        jLabelSelectAllAlgorithms.setText("select all Algorithms");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 15;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(5, 0, 0, 0);
        add(jLabelSelectAllAlgorithms, gridBagConstraints);
        jLabelSelectAllAlgorithms.setToolTipText("Select all elementary net properties.");

        jRadioButtonSelectAllAlgorithms.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonSelectAllAlgorithmsActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 15;
        gridBagConstraints.insets = new java.awt.Insets(5, 0, 0, 0);
        add(jRadioButtonSelectAllAlgorithms, gridBagConstraints);

        jLabelTransitionWithoutPrePlace.setText("Reactions without pre-species");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        add(jLabelTransitionWithoutPrePlace, gridBagConstraints);

        jLabelTransitionWithoutPostPlace.setText("Reactions without post-species");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        add(jLabelTransitionWithoutPostPlace, gridBagConstraints);

        jLabelPlaceWithoutPreTransition.setText("Species without pre-reactions");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        add(jLabelPlaceWithoutPreTransition, gridBagConstraints);

        jLabelPlaceWithoutPostTransition.setText("Species without post-reactions");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        add(jLabelPlaceWithoutPostTransition, gridBagConstraints);

        jLabelTransitionWithoutPrePlaceColor.setBackground(new java.awt.Color(255, 0, 0));
        jLabelTransitionWithoutPrePlaceColor.setForeground(new java.awt.Color(255, 0, 0));
        jLabelTransitionWithoutPrePlaceColor.setText("XX");
        jLabelTransitionWithoutPrePlaceColor.setOpaque(true);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
        add(jLabelTransitionWithoutPrePlaceColor, gridBagConstraints);
        //jLabelTransitionWithoutPrePlaceColor.setToolTipText("Change color if 'transition without pre-place' is not selected");

        jLabelTransitionWithoutPostPlaceColor.setBackground(new java.awt.Color(0, 255, 0));
        jLabelTransitionWithoutPostPlaceColor.setForeground(new java.awt.Color(0, 255, 0));
        jLabelTransitionWithoutPostPlaceColor.setText("XX");
        jLabelTransitionWithoutPostPlaceColor.setOpaque(true);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
        add(jLabelTransitionWithoutPostPlaceColor, gridBagConstraints);
        //jLabelTransitionWithoutPostPlaceColor.setToolTipText("Change color if 'transition without post-place' is not selected");

        jLabelPlaceWithoutPreTransitionColor.setBackground(new java.awt.Color(0, 0, 255));
        jLabelPlaceWithoutPreTransitionColor.setForeground(new java.awt.Color(0, 0, 255));
        jLabelPlaceWithoutPreTransitionColor.setText("XX");
        jLabelPlaceWithoutPreTransitionColor.setOpaque(true);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
        add(jLabelPlaceWithoutPreTransitionColor, gridBagConstraints);
        //jLabelPlaceWithoutPreTransitionColor.setToolTipText("Change color if 'place without pre-transition' is not selected");

        jLabelPlaceWithoutPostTransitionColor.setBackground(new java.awt.Color(255, 255, 0));
        jLabelPlaceWithoutPostTransitionColor.setForeground(new java.awt.Color(255, 255, 0));
        jLabelPlaceWithoutPostTransitionColor.setText("XX");
        jLabelPlaceWithoutPostTransitionColor.setOpaque(true);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
        add(jLabelPlaceWithoutPostTransitionColor, gridBagConstraints);
        //jLabelPlaceWithoutPostTransitionColor.setToolTipText("Change color if 'place without pre-transition' is not selected");

        jButtonCheckAlgorithms.setText("Check Algorithms");
        jButtonCheckAlgorithms.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCheckAlgorithmsActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 16;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.insets = new java.awt.Insets(10, 0, 0, 0);
        add(jButtonCheckAlgorithms, gridBagConstraints);

        jLabelSubConservative.setText("sub-conservative");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 11;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jLabelSubConservative, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 11;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 0);
        add(jCheckBoxSubConservative, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 11;
        gridBagConstraints.insets = new java.awt.Insets(1, 0, 0, 2);
        add(jLabelSubConservativeReturn, gridBagConstraints);

        helpButton.setText("Help");
        helpButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                helpButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 18;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.insets = new java.awt.Insets(15, 0, 0, 0);
        add(helpButton, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents

    private void jCheckBoxTransitionWithoutPrePlaceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxTransitionWithoutPrePlaceActionPerformed
        Color color = jLabelTransitionWithoutPrePlaceColor.getBackground();
        if (jCheckBoxTransitionWithoutPrePlace.isSelected()) {
            LOGGER.info("Colouring transitions without pre-places");
            transitionWithoutPrePlace = new TransitionWithoutPrePlace(petriNet);
            transitionWithoutPrePlace.runAlgorithm();

            for (Transition t : transitionWithoutPrePlace.returnAlgorithmValue()) {
                this.setColorOfNetViewerNode(t, color);
                colorMap.addColorToList(t.id(), color);
            }
            jLabelTransitionWithoutPrePlaceColor.removeMouseListener(jLabelTransitionWithoutPrePlaceColor.getMouseListeners()[0]);//removes the first MouseListener (MyColorOptionsMouseListener)
            LOGGER.info("Successfully coloured transitions without pre-places");

        } else {
            LOGGER.info("Removing colouring from transitions without pre-places");
            for (Transition t : transitionWithoutPrePlace.returnAlgorithmValue()) {
                colorMap.removeColorFromList(t.id(), color);
                if (colorMap.getColorFromList(t.id()) == null) {
                    this.setColorOfNetViewerNode(t, NetViewer.DEFAULT_COLOR_TRANSITIONS);
                } else {
                    this.setColorOfNetViewerNode(t, colorMap.getColorFromList(t.id()));
                }
            }
            jLabelTransitionWithoutPrePlaceColor.addMouseListener(new MyColorOptionsMouseListener(jLabelTransitionWithoutPrePlaceColor));
            LOGGER.info("Successfully removed colouring from transitions without pre-places");
        }
    }//GEN-LAST:event_jCheckBoxTransitionWithoutPrePlaceActionPerformed

    private void jCheckBoxTransitionWithoutPostPlaceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxTransitionWithoutPostPlaceActionPerformed
        Color color = jLabelTransitionWithoutPostPlaceColor.getBackground();
        if (jCheckBoxTransitionWithoutPostPlace.isSelected()) {
            LOGGER.info("Colouring transitions without post-places");
            transitionWithoutPostPlace = new TransitionWithoutPostPlace(petriNet);
            transitionWithoutPostPlace.runAlgorithm();

            for (Transition t : transitionWithoutPostPlace.returnAlgorithmValue()) {
                this.setColorOfNetViewerNode(t, color);

                colorMap.addColorToList(t.id(), color);
            }
            jLabelTransitionWithoutPostPlaceColor.removeMouseListener(jLabelTransitionWithoutPostPlaceColor.getMouseListeners()[0]);//removes the first MouseListener (MyColorOptionsMouseListener)
            LOGGER.info("Successfully coloured transitions without post-places");
        } else {
            LOGGER.info("Removing colouring from transitions without post-places");
            for (Transition t : transitionWithoutPostPlace.returnAlgorithmValue()) {
                colorMap.removeColorFromList(t.id(), color);
                if (colorMap.getColorFromList(t.id()) == null) {
                    this.setColorOfNetViewerNode(t, NetViewer.DEFAULT_COLOR_TRANSITIONS);
                } else {
                    this.setColorOfNetViewerNode(t, colorMap.getColorFromList(t.id()));
                }
            }
            jLabelTransitionWithoutPostPlaceColor.addMouseListener(new MyColorOptionsMouseListener(jLabelTransitionWithoutPostPlaceColor));
            LOGGER.info("Successfully removed colouring from transitions without pre-places");
        }
    }//GEN-LAST:event_jCheckBoxTransitionWithoutPostPlaceActionPerformed

    private void jCheckBoxPlaceWithoutPreTransitionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxPlaceWithoutPreTransitionActionPerformed
        Color color = jLabelPlaceWithoutPreTransitionColor.getBackground();
        if (jCheckBoxPlaceWithoutPreTransition.isSelected()) {
            LOGGER.info("Colouring places without pre-transitions");
            placeWithoutPreTransition = new PlaceWithoutPreTransition(petriNet);
            placeWithoutPreTransition.runAlgorithm();

            for (Place p : placeWithoutPreTransition.returnAlgorithmValue()) {
                this.setColorOfNetViewerNode(p, color);

                colorMap.addColorToList(p.id(), color);
            }
            jLabelPlaceWithoutPreTransitionColor.removeMouseListener(jLabelPlaceWithoutPreTransitionColor.getMouseListeners()[0]);//removes the first MouseListener (MyColorOptionsMouseListener)
            LOGGER.info("Successfully coloured places without pre-transitions");
        } else {
            LOGGER.info("Removing colouring from places without pre-transitions");
            for (Place p : placeWithoutPreTransition.returnAlgorithmValue()) {
                colorMap.removeColorFromList(p.id(), color);
                if (colorMap.getColorFromList(p.id()) == null) {
                    this.setColorOfNetViewerNode(p, NetViewer.DEFAULT_COLOR_PLACES);
                } else {
                    this.setColorOfNetViewerNode(p, colorMap.getColorFromList(p.id()));
                }
            }
            jLabelPlaceWithoutPreTransitionColor.addMouseListener(new MyColorOptionsMouseListener(jLabelPlaceWithoutPreTransitionColor));
            LOGGER.info("Successfully removed colouring from places without pre-transitions");
        }
    }//GEN-LAST:event_jCheckBoxPlaceWithoutPreTransitionActionPerformed

    private void jCheckBoxPlaceWithoutPostTransitionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxPlaceWithoutPostTransitionActionPerformed
        Color color = jLabelPlaceWithoutPostTransitionColor.getBackground();
        if (jCheckBoxPlaceWithoutPostTransition.isSelected()) {
            LOGGER.info("Colouring places without post-transitions");
            placeWithoutPostTransition = new PlaceWithoutPostTransition(petriNet);
            placeWithoutPostTransition.runAlgorithm();

            for (Place p : placeWithoutPostTransition.returnAlgorithmValue()) {
                this.setColorOfNetViewerNode(p, color);

                colorMap.addColorToList(p.id(), color);
            }
            jLabelPlaceWithoutPostTransitionColor.removeMouseListener(jLabelPlaceWithoutPostTransitionColor.getMouseListeners()[0]); //removes the first MouseListener (MyColorOptionsMouseListener)
            LOGGER.info("Successfully coloured places without post-transitions");
        } else {
            LOGGER.info("Removing colouring from places without post-transitions");
            for (Place p : placeWithoutPostTransition.returnAlgorithmValue()) {
                colorMap.removeColorFromList(p.id(), color);
                if (colorMap.getColorFromList(p.id()) == null) {
                    this.setColorOfNetViewerNode(p, NetViewer.DEFAULT_COLOR_PLACES);
                } else {
                    this.setColorOfNetViewerNode(p, colorMap.getColorFromList(p.id()));
                }
            }
            jLabelPlaceWithoutPostTransitionColor.addMouseListener(new MyColorOptionsMouseListener(jLabelPlaceWithoutPostTransitionColor));
            LOGGER.info("Successfully removed colouring from places without post-transitions");
        }
    }//GEN-LAST:event_jCheckBoxPlaceWithoutPostTransitionActionPerformed

    private void jRadioButtonSelectAllAlgorithmsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonSelectAllAlgorithmsActionPerformed
        netPropertiesPanelLogic = new NetPropertiesPanelLogic(algorithmMap, labelMap);
        if (jRadioButtonSelectAllAlgorithms.isSelected()) {
            LOGGER.info("Selected all algorithms");
            netPropertiesPanelLogic.selectAllAlgorithmsIsSelected();
        } else {
            LOGGER.info("Deselected all algorithms");
            netPropertiesPanelLogic.selectAllAlgorithmsIsNotSelected();
        }
    }//GEN-LAST:event_jRadioButtonSelectAllAlgorithmsActionPerformed

    private void jButtonCheckAlgorithmsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonCheckAlgorithmsActionPerformed
        LOGGER.info("Checking selected properties");
        if (jButtonCheckAlgorithmIsSelected == false) {
            netPropertiesPanelLogic = new NetPropertiesPanelLogic(algorithmMap, labelMap);
            if (petriNet.places().size() + petriNet.transitions().size() == 0) { //checks if there is a Petri net selected
                LOGGER.info("No petri net selected to check for properties");
                netPropertiesPanelLogic.checkAlgorithms(0); //set the return text to 'no net'
                return;
            }
            netPropertiesPanelLogic.checkAlgorithms();
            jButtonCheckAlgorithmIsSelected = true;
        } else {
            netPropertiesPanelLogic.checkAlgorithmsNot();
            jButtonCheckAlgorithmIsSelected = false;
        }
        LOGGER.info("Successfully checked selected properties");
    }//GEN-LAST:event_jButtonCheckAlgorithmsActionPerformed

    private void helpButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_helpButtonActionPerformed
        NetPropertyHelpDialog hd = new NetPropertyHelpDialog();
        hd.setVisible(true);
    }//GEN-LAST:event_helpButtonActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton helpButton;
    private javax.swing.JButton jButtonCheckAlgorithms;
    private javax.swing.JCheckBox jCheckBoxConnected;
    private javax.swing.JCheckBox jCheckBoxConservative;
    private javax.swing.JCheckBox jCheckBoxHomogenous;
    private javax.swing.JCheckBox jCheckBoxNonBlockingMultiplicity;
    private javax.swing.JCheckBox jCheckBoxOrdinary;
    protected javax.swing.JCheckBox jCheckBoxPlaceWithoutPostTransition;
    protected javax.swing.JCheckBox jCheckBoxPlaceWithoutPreTransition;
    private javax.swing.JCheckBox jCheckBoxPure;
    private javax.swing.JCheckBox jCheckBoxStaticConflictFree;
    private javax.swing.JCheckBox jCheckBoxStronglyConnected;
    private javax.swing.JCheckBox jCheckBoxSubConservative;
    protected javax.swing.JCheckBox jCheckBoxTransitionWithoutPostPlace;
    protected javax.swing.JCheckBox jCheckBoxTransitionWithoutPrePlace;
    private javax.swing.JLabel jLabelConnected;
    private javax.swing.JLabel jLabelConnectedReturn;
    private javax.swing.JLabel jLabelConservative;
    private javax.swing.JLabel jLabelConservativeReturn;
    private javax.swing.JLabel jLabelElementaryNetPropertiesHeadline;
    private javax.swing.JLabel jLabelHomogenous;
    private javax.swing.JLabel jLabelHomogenousReturn;
    private javax.swing.JLabel jLabelNonBlockingMultiplicity;
    private javax.swing.JLabel jLabelNonBlockingMultiplicityReturn;
    private javax.swing.JLabel jLabelOneSidedNodesHeadline;
    private javax.swing.JLabel jLabelOrdinary;
    private javax.swing.JLabel jLabelOrdinaryReturn;
    private javax.swing.JLabel jLabelPlaceWithoutPostTransition;
    private javax.swing.JLabel jLabelPlaceWithoutPostTransitionColor;
    private javax.swing.JLabel jLabelPlaceWithoutPreTransition;
    private javax.swing.JLabel jLabelPlaceWithoutPreTransitionColor;
    private javax.swing.JLabel jLabelPure;
    private javax.swing.JLabel jLabelPureReturn;
    private javax.swing.JLabel jLabelSelectAllAlgorithms;
    private javax.swing.JLabel jLabelStaticConflictFree;
    private javax.swing.JLabel jLabelStaticConflictFreeReturn;
    private javax.swing.JLabel jLabelStronglyConnected;
    private javax.swing.JLabel jLabelStronglyConnectedReturn;
    private javax.swing.JLabel jLabelSubConservative;
    private javax.swing.JLabel jLabelSubConservativeReturn;
    private javax.swing.JLabel jLabelTransitionWithoutPostPlace;
    private javax.swing.JLabel jLabelTransitionWithoutPostPlaceColor;
    private javax.swing.JLabel jLabelTransitionWithoutPrePlace;
    private javax.swing.JLabel jLabelTransitionWithoutPrePlaceColor;
    private javax.swing.JRadioButton jRadioButtonSelectAllAlgorithms;
    // End of variables declaration//GEN-END:variables

    /**
     * Create a HashMap, where the CheckBox and the related algorithm are
     * stored.
     *
     * @return
     */
    private HashMap<JCheckBox, NetPropertyAlgorithm> getAlgorithmMap() {
        ordinary = new Ordinary(petriNet);
        homogenous = new Homogenous(petriNet);
        nonBlockingMultiplicity = new NonBlockingMultiplicity(petriNet);
        pure = new Pure(petriNet);
        conservative = new Conservative(petriNet);
        subConservative = new SubConservative(petriNet);
        staticConflictFree = new StaticConflictFree(petriNet);
        connected = new Connected(petriNet);
        stronglyConnected = new StronglyConnected(petriNet);
        algorithmMap.put(jCheckBoxOrdinary, ordinary);
        algorithmMap.put(jCheckBoxHomogenous, homogenous);
        algorithmMap.put(jCheckBoxNonBlockingMultiplicity, nonBlockingMultiplicity);
        algorithmMap.put(jCheckBoxPure, pure);
        algorithmMap.put(jCheckBoxConservative, conservative);
        algorithmMap.put(jCheckBoxSubConservative, subConservative);
        algorithmMap.put(jCheckBoxStaticConflictFree, staticConflictFree);
        algorithmMap.put(jCheckBoxConnected, connected);
        algorithmMap.put(jCheckBoxStronglyConnected, stronglyConnected);
        return algorithmMap;
    }

    private HashMap<JCheckBox, NetPropertyAlgorithm> getOneSidedAlgorithmMap() {
        transitionWithoutPrePlace = new TransitionWithoutPrePlace(petriNet);
        transitionWithoutPostPlace = new TransitionWithoutPostPlace(petriNet);
        placeWithoutPreTransition = new PlaceWithoutPreTransition(petriNet);
        placeWithoutPostTransition = new PlaceWithoutPostTransition(petriNet);
        oneSidedAlgorithmMap.put(jCheckBoxTransitionWithoutPrePlace, transitionWithoutPrePlace);
        oneSidedAlgorithmMap.put(jCheckBoxTransitionWithoutPostPlace, transitionWithoutPostPlace);
        oneSidedAlgorithmMap.put(jCheckBoxPlaceWithoutPreTransition, placeWithoutPreTransition);
        oneSidedAlgorithmMap.put(jCheckBoxPlaceWithoutPostTransition, placeWithoutPostTransition);
        return oneSidedAlgorithmMap;
    }

    /**
     * Create a HashMap, where the CheckBox and the related jLabel are stored.
     * So you can update the return value.
     *
     * @return
     */
    private HashMap<JCheckBox, JLabel> getLabelMap() {
        labelMap.put(jCheckBoxOrdinary, jLabelOrdinaryReturn);
        labelMap.put(jCheckBoxHomogenous, jLabelHomogenousReturn);
        labelMap.put(jCheckBoxNonBlockingMultiplicity, jLabelNonBlockingMultiplicityReturn);
        labelMap.put(jCheckBoxPure, jLabelPureReturn);
        labelMap.put(jCheckBoxConservative, jLabelConservativeReturn);
        labelMap.put(jCheckBoxSubConservative, jLabelSubConservativeReturn);
        labelMap.put(jCheckBoxStaticConflictFree, jLabelStaticConflictFreeReturn);
        labelMap.put(jCheckBoxConnected, jLabelConnectedReturn);
        labelMap.put(jCheckBoxStronglyConnected, jLabelStronglyConnectedReturn);

        return labelMap;
    }

    @Override
    public void netChanged() {
        LOGGER.debug("Handling net change for NetPropertiesPanel");
        if (netPropertiesPanelLogic != null) {
            netPropertiesPanelLogic.checkAlgorithmsNot();
            netPropertiesPanelLogic.selectAllAlgorithmsIsNotSelected();
        }
        LOGGER.debug("Successfully handled net change for NetPropertiesPanel");
    }
}
